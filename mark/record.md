



## 一.总线设计

### ICB总线设计

1. 仅有2个独立的通道，读和写操作公用地址通道，共用结果返回通道
2. 与AXI总线一样，采用分离的地址和数据阶段
3. 支持地址区间寻址，支持任意的主从数目
    - 一主一丛
    - 一主多从
    - 多主一从
    - 多主多从
4. 每个读/写操作都会产生地址，而不想AXI中只有起始地址(不支持突发传输)
5. 支持地址非对齐访问，使用掩码控制部分写操作
6. 支持多个置外交易 outstanding transaction
7. 不支持按序返回按序完成，反馈通道必须按照顺序返回结果
8. 非常利于添加流水线级数

### ICB信号

| 通道     | 方向   | 宽度 | 信号名        | 描述                                    |
| -------- | ------ | ---- | ------------- | --------------------------------------- |
| 命令信道 | output | 1    | icb_cmd_valid | 主设备向从设备发出的读/写请求信号       |
| 命令信道 | input  | 1    | icb_cmd_ready | 从设备向主设备返回的读/写接受信号       |
| 命令信道 | output | 1    | icb_cmd_read  | 读信号                                  |
| 命令信道 | output | DW   | icb_cmd_addr  | 读/写地址                               |
| 命令信道 | output | DW   | icb_cmd_wdata | 写数据                                  |
| 命令信道 | output | DW/8 | icb_cmd_wmask | 写操作的字节掩码                        |
| 反馈通道 | input  | 1    | icb_rsp_valid | 从设备向主设备发送的读/写反馈的请求信号 |
| 反馈通道 | output | 1    | icb_rsp_ready | 主设备向从设备发送的读/写反馈的接受信号 |
| 反馈通道 | input  | DW   | icb_rsp_rdata | 读反馈数据                              |
| 反馈通道 | input  | 1    | icb_rsp_err   | 读反馈错误                              |
|          |        |      |               |                                         |

## 二.取指

- 将指令从内存中取出

- 简单译码
- 分支预测
- 暂时不考虑压缩指令

### 简单译码

普通指令或者是分支/跳转指令

- 分支指令: JXX

    pc_next = pc + imm

- 跳转指令: JAL && JALR

    JAL: pc_next = pc + imm

    JALR: pc_next = rs1 + imm

### 分支预测

- BXX指令：采用静态分支预测，向后跳转预测为跳，向前跳转预测为不跳
- JAL：PC + OFFSET
- JALR： RS1 + OFFSET

#### 分支预测操作数

- jal和bxx使用PC作为基地址

- jalr需要使用寄存器中的值作为基地址

  - rs1 = x0

    基地址 = 0

  - rs1 = x1

    x1常用于函数调用的返回地址，可以做特殊优化

  - 其他寄存器

### PC生成

- 顺序取指
- 分支指令
- 流水线冲刷

### 取指令



## 三.译码

译码究竟需要从指令里面得到什么，或者说是指令里面包含了什么

- 源操作数索引 `rs1` `rs2`
- 写会寄存器索引`rd`
- 这条指令需要做什么
  - 算数逻辑运算
  - 加载/存储
  - 分支/跳转

译码之后指令需要被派遣到不同的执行单元取执行

- ALU

  - 算数逻辑指令

    1. reg-reg

       rd = rs1 op rs2

    2. reg-imm

       rd = rs1 op imm

  - LOAD/STORE

    1. load

       rd = M[rs1 + imm]

    2. store

       M[rs1 + imm] = rs2

  - 分支指令

    rs1 op rs2
    
  - LUI

    rd = 0 +imm;

  - AUIPC

    rd = pc + imm;

  对于ALU来说op1始终为rs1，而op2可能为imm

- MUL

- DIV

#### 指令译码

从指令中译码出`rs1`, `rs2`, `rd`, 指令类型

#### 访问寄存器

访问寄存器





## 中断与异常

### 中断

处理器核在顺序执行程序指令流的过程中，被别的请求打断而去处理其他的事情，等到处理完成再回来继续执行。

- 可能存在多个中断源向cpu发出中断，需要中断仲裁，选择处理哪一个中断。中断存在着优先级，类似于vip与普通用户。
- 处理器在处理中断的过程中有一个优先级更高的中断。
    1. 不响应新的中断，等到当前中断处理完成再处理新的中断，称为不支持中断嵌套。
    2. 终止当前中断处理程序，处理新的中断请求，支持中断嵌套。
    3. 如果新来的中断优先级 <= 当前的中断，直接忽略。

#### 中断需要做什么

- 保存PC

    一方面可以等到中断处理程序执行完再跳转回来，也可以知道是什么指令发生了中断

- 保存中断原因

- 保存寄存器文件

    保存现场 >>> 恢复现场

- 跳转到中断处理程序

### 异常

处理器核在顺序执行程序的过程中遇到了异常的事件而终止当前的程序转而去处理该异常

- 异常和中断最大的区别是中断是外部事件，而异常是内部事件，例如地址不对齐。
- 发生异常会进入异常处理程序。

### 广义上的异常

- 中断和异常本质上是一样的
- 中断和异常都可以被认为是广义上的异常，发生了异常去执行异常处理程序，执行完成再跳转回来执行。

#### 同步异常

执行程序指令流或者试图执行指令流而造成的异常，这种异常能够被精准的定位，在相同的环境下执行，无论多少次都会精准的重现。例如执行系统调用或者是除0异常。

#### 异步异常

不能够被精准定位的异常，在同样的环境下执行每次发生异常的PC都不一样。

最常见的异步异常就是外部中断，例如键盘中断，是未知事件。

响应后处理器状态：

1. 精准异步异常：响应异常后的处理器状态能够精确的反映为一条指令的边界，即一条指令完成之后处理器的状态。
2. 非精准异步异常：响应异常后的处理器状态无法精确的反映为一条指令的边界，可能是一条指令执行了一半被打断结果。

#### 典型的异常类型

##### 同步异常

- 取指令取到非法地址
- 读写数据访问地址属性出错
- 取指令地址非对齐错误
- 非法指令错误
- 执行调试断点指令

##### 精准异步异常

- 外部中断

##### 非精准异步异常

- 读写存储器异常

    访问存储器需要一定的时间，处理器不能可能一直等着，而是继续执行后续指令。等到访存结束，发生了访存异常，此时处理器可能执行到了后面的程序，难以精准定位。

### RISCV架构的异常处理

- 机器模式
- 监督模式
- 用户模式

#### RISCV的异常处理流程

1. 停止执行当前的指令流，转而从CSR中的`mtvec`(Machine Trap-vector Base-Address Register)中的PC地址开始执行

    mtvec:

    - mtvec是一个可读可写的CSR，软件可以修改里面的值

    - 高30位位BASE域，低2位为MODE位

        1. MODE == 0, 异常处理跳转到BASE值指定的PC

        2. MODE == 1, 狭义的异常发生时跳转到BASE值指定的PC处，狭义的中断发生时，处理器跳转到BASE + 4*CAUSE值指示的PC地址，CAUSE的值表示中断对应的异常编号。

            例如机器时钟中断的异常编号为7, 跳转地址为 BASE + 4 * 7

2. 更新其他CSR

    - 机器模式异常原因寄存器`mcause` (Machine Cause Register)

        反应当前的异常种类

        高1位为interupt，低31位为编号位

    - 机器模式异常PC寄存器` mepc`(Machine Exception Programer Counter)

        异常返回地址，进入异常时，将mepc更新为遇到异常指令的PC，作为异常的返回地址。

        软件可以修改，意味着软件可以决定异常处理完成之后的返回地址

        - 中断：mepc为发生中断的下一条指令的PC
        - 异常：mepc为发生异常指令的PC, 如果是由ecall, ebreak产生的异常如果使用当前指令的PC作为返回地址会进入死循环。mepc = mepc + 4

    - 机器模式异常值寄存器`mtval`(Machine Trap Value Register)

    - 机器模式状态寄存器`mstatus`

RISCV规定进入异常和退出异常没有硬件自动保存和恢复上下文(寄存器文件)的机制，需要软件自己保存和恢复上下文。

#### 中断类型

1. 外部中断
2. 计时器中断
3. 软件中断
4. 调试中断

### RISCX支持异常类型

#### 1.中断

| 异常编号 | 类型               | 同步/异步 | 描述 |
| -------- | ------------------ | --------- | ---- |
| 3        | 机器模式软件中断   | 精准异步  |      |
| 7        | 机器模式计时器中断 | 精准异步  |      |
| 11       | 机器模式外部中断   | 精准异步  |      |

#### 2.异常

| 异常编号 | 类型                    | 同步/异步  |                         |
| -------- | ----------------------- | ---------- | ----------------------- |
| 0        | 指令地址不对齐          | 同步       | 指令PC不对齐            |
| 1        | 指令访存错误            | 同步       | 取指访存错误            |
| 2        | 非法指令                | 同步       |                         |
| 3        | 断点                    | 同步       | EBREAK指令              |
| 4        | 读存储器地址不对齐      | 同步       | LOAD指令地址不对齐      |
| 5        | 读存储器访问错误        | 非精准异步 | LOAD指令访存错误        |
| 6        | 写存储器与AMO地址不对齐 | 同步       | STORE/AMO指令地址不对齐 |
| 7        | 写存储器与AMO访存错误   | 非精准异步 | STORE/AMO指令访存错误   |
| 11       | 机器模式环境调用        | 同步       | 机器模式下执行ECALL指令 |

#### 3.五级流水顺序执行cpu的异常解决策略

- 写回阶段处理异常
- PC和异常跟着指令在cpu中流动
- 当指令发送异常的时不可以修改存储器或者是寄存器

